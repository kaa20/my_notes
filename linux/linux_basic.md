
## 4.Программные каналы и команды
### 4.1 Перенаправление потоков ввода/вывода
#### Потоки данных stdin, stdout и stderr
Командная оболочка bash поддерживает три типа базовых потоков данных; она принимает данные из стандартного потока ввода stdin (поток 0), отправляет данные в стандартный поток вывода stdout (поток 1), а также отправляет сообщения об ошибках в стандартный поток ошибок stderr (поток 2).

Приведенная ниже иллюстрация является графической интерпретацией этих трех потоков данных.

Клавиатура обычно служит источником данных для стандартного потока ввода stdin, в то время, как стандартные потоки вывода stdout и ошибок stderr используются для вывода данных. Новых пользователей Linux может смущать подобное разделение, так как не существует очевидного способа дифференцирования стандартных потоков вывода stdout и ошибок stderr. Опытные же пользователи знают о том, что разделение стандартных потоков вывода и ошибок может оказаться весьма полезным.

![image](./assets/images/bash_ioredirection_keyboard_display_ru.png)

В следующем разделе будет рассказано о том, как осуществляется перенаправление упомянутых потоков данных.

#### Перенаправление стандартного потока вывода
###### Операция перенаправления потока данных stdout (>)

Перенаправление стандартного потока вывода stdout может быть осуществлено с помощью символа знака "больше". В том случае, если при разборе строки команды командная оболочка обнаруживает символ знака >, она удаляет данные из файла и перенаправлет данные из стандартного потока вывода в него.

![image](./assets/images/bash_output_redirection_ru.png)

Нотация > фактически является аббревиатурой для 1> (в данном случае стандартный поток вывода обозначается как поток номер 1).

```
[paul@RHELv4u3 ~]$ echo Сегодня холодно! Сегодня холодно! 
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня холодно! 
[paul@RHELv4u3 ~]$
```

Обратите внимание на то, что командная оболочка bash фактически удаляет описание операции перенаправления потока данных из строки команды перед исполнением этой команды, представленной аргументом 0. Это значит, что в случае исполнения данной команды:

```
echo привет > greetings.txt
```

командная оболочка будет рассматривать только два аргумента (echo = аргумент 0, привет = аргумент 1). Описание операции перенаправления потока данных удаляется перед началом подсчета количества аргументов.

###### Содержимое выходного файла удаляется

В том случае, если в процессе разбора строки команды командная оболочка обнаружит символ знака >, содержимое указанного после него файла будет удалено! Ввиду того, что описанная процедура выполняется перед извлечением аргумента 0, содержимое файла будет удалено даже в случае неудачного исполнения команды!

```
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня холодно! 
[paul@RHELv4u3 ~]$ zcho Сегодня холодно! > winter.txt -bash: zcho: команда не найдена.. 
[paul@RHELv4u3 ~]$ cat winter.txt 
[paul@RHELv4u3 ~]$
```

###### Параметр командной оболочки noclobber

Удаление содержимого файла при использовании оператора > может быть предотвращено путем установки параметра командной оболочки noclobber.

```
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня холодно! 
[paul@RHELv4u3 ~]$ set -o noclobber 
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt -bash: winter.txt: не могу переписать уже существующий файл 
[paul@RHELv4u3 ~]$ set +o noclobber 
[paul@RHELv4u3 ~]$
```

###### Нейтрализация влияния параметра командной оболочки noclobber

Влияние параметра командной оболочки noclobber может быть нейтрализовано с помощью оператора >|.

```
[paul@RHELv4u3 ~]$ set -o noclobber 
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt -bash: winter.txt: не могу переписать уже существующий файл 
[paul@RHELv4u3 ~]$ echo Сегодня очень холодно! >| winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня очень холодно! 
[paul@RHELv4u3 ~]$
```

###### Оператор дополнения >>

Следует использовать оператор >> для записи данных из стандартного потока вывода в конец файла без предварительного удаления содержимого этого файла.

```
[paul@RHELv4u3 ~]$ echo Сегодня холодно! > winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня холодно! 
[paul@RHELv4u3 ~]$ echo Когда же наступит лето ? >> winter.txt 
[paul@RHELv4u3 ~]$ cat winter.txt Сегодня холодно! Когда же наступит лето ? 
[paul@RHELv4u3 ~]$
```

#### Перенаправление стандартного потока ошибок
###### Операция перенаправления потока данных stderr (2>)

Перенаправление стандартного потока ошибок осуществляется с помощью оператора 2>. Такое перенаправление может оказаться очень полезным для предотвращения заполнения вашего экрана сообщениями об ошибках.

![image](./assets/images/bash_error_redirection_ru.png)

В примере ниже показана методика перенаправления данных из стандартного потока вывода в файл, а данных из стандартного потока ошибок - в специальный файл устройства /dev/null. Запись 1> идентична записи >.

```
[paul@RHELv4u3 ~]$ find / > allfiles.txt 2> /dev/null 
[paul@RHELv4u3 ~]$
```

###### Операция перенаправления нескольких потоков данных 2>&1

Для перенаправления данных как из стандартного потока вывода, так и из стандартного потока ошибок в один и тот же файл следует использовать конструкцию 2>&1.

```
[paul@RHELv4u3 ~]$ find / > allfiles_and_errors.txt 2>&1 
[paul@RHELv4u3 ~]$
```

Помните о том, что последовательность операций перенаправления потоков данных имеет значение. К примеру, команда

```
ls > dirlist 2>&1
```

позволяет перенаправить как данные из стандартного потока вывода (с файловым дескриптором 1), так и данные из стандартного потока ошибок (с файловым дескриптором 2) в файл dirlist, в то время, как команда

```
ls 2>&1 > dirlist
```

позволяет перенаправить только данные из стандартного потока вывода в файл dirlist, так как с помощью данной команды осуществляется копирование дескриптора стандартного потока вывода в дескриптор стандартного потока ошибок перед тем, как стандартный поток вывода перенаправляется в файл dirlist.

#### Перенаправление стандартного потока вывода и программные каналы
По умолчанию вы не можете использовать утилиту grep для обработки данных стандартного потока ошибок stderr приложения при использовании программных каналов в рамках строки команды, так как данная утилита получает данные исключительно из стандартного потока вывода stdout приложения.

```
paul@debian7:~$ rm file42 file33 file1201 | grep file42 rm: невозможно удалить "file42": Нет такого файла или каталога rm: невозможно удалить "file33": Нет такого файла или каталога rm: невозможно удалить "file1201": Нет такого файла или каталога
```

С помощью конструкции 2>&1 вы можете переправить данные из стандартного потока ошибок stderr в стандартный поток вывода stdout приложения. Это обстоятельство позволяет обрабатывать передаваемые посредством программного канала данные из обоих потоков с помощью следующей команды.

```
paul@debian7:~$ rm file42 file33 file1201 2>&1 | grep file42 rm: невозможно удалить "file42": Нет такого файла или каталога
```

Вы не можете одновременно использовать конструкции 1>&2 и 2>&1 для осуществления обмена файловых дескрипторов между стандартным потоком вывода stdout и стандартным потоком ошибок stderr.

```
paul@debian7:~$ rm file42 file33 file1201 2>&1 1>&2 | grep file42 rm: невозможно удалить "file42": Нет такого файла или каталога 
paul@debian7:~$ echo file42 2>&1 1>&2 | sed 's/file42/FILE42/' FILE42
```

Вам потребуется третий поток данных для осуществления обмена файловых дескрипторов между стандартным потоком вывода stdout и стандартным потоком ошибок stderr перед символом для создания программного канала.

```
paul@debian7:~$ echo file42 3>&1 1>&2 2>&3 | sed 's/file42/FILE42/' file42 
paul@debian7:~$ rm file42 3>&1 1>&2 2>&3 | sed 's/file42/FILE42/' rm: невозможно удалить "FILE42": Нет такого файла или каталога
```

#### Объединение стандартных потоков вывода stdout и ошибок stderr
Конструкция &> позволяет объединить стандартные потоки вывода stdout и ошибок stderr в рамках одного потока данных (причем данные будут сохраняться в файле).

```
paul@debian7:~$ rm file42 &> out_and_err 
paul@debian7:~$ cat out_and_err rm: невозможно удалить "file42": Нет такого файла или каталога 
paul@debian7:~$ echo file42 &> out_and_err 
paul@debian7:~$ cat out_and_err file42 
paul@debian7:~$
```

#### Перенаправление стандартного потока ввода
###### Операция перенаправления потока данных stdin (<)

Перенаправление стандартного потока ввода stdin осуществляется с помощью оператора < (являющегося краткой версией оператора 0<).

```
[paul@RHEL4b ~]$ cat < text.txt one two [paul@RHEL4b ~]$ tr 'onetw' 'ONEZZ' < text.txt ONE ZZO [paul@RHEL4b ~]$
```

###### Структура < here document

Структура here document (иногда называемая структурой here-is-document) является механизмом для ввода данных до момента обнаружения определенной последовательности символов (обычно EOF). Маркер EOF может быть либо введен вручную, либо вставлен автоматически при нажатии комбинации клавиш Ctrl-D.

```
[paul@RHEL4b ~]$ cat <EOF > text.txt > один > два > EOF [paul@RHEL4b ~]$ cat text.txt один два [paul@RHEL4b ~]$ cat <brol > text.txt > brel > brol [paul@RHEL4b ~]$ cat text.txt brel [paul@RHEL4b ~]$
```

###### Структура < here string

Структура here string может использоваться для непосредственной передачи строк команде. При использовании данной структуры достигается такой же эффект, как и при использовании команды echo строка | команда (но вы сможете избежать создания одного дополнительного процесса).

```
paul@ubu1110~$ base64 < linux-training.be bGludXgtdHJhaW5pbmcuYmUK paul@ubu1110~$ base64 -d << bGludXgtdHJhaW5pbmcuYmUK linux-training.be
```

Для получения дополнительной информации об алгоритме base64 следует обратиться к стандарту rfc 3548.

#### Неоднозначное перенаправление потоков ввода/вывода
Командная оболочка будет осуществлять разбор всей строки команды перед осуществлением перенаправления потоков ввода/вывода. Следующая команда является хорошо читаемой и корректной:

```
cat winter.txt > snow.txt 2> errors.txt
```

Но следующая команды также является корректной, хотя и хуже читается:

```
2> errors.txt cat winter.txt > snow.txt
```

Даже следующая команда будет прекрасно интерпретироваться командной оболочкой:

```
< winter.txt > snow.txt 2> errors.txt cat
```

#### Быстрая очистка содержимого файла
Так какой же самый быстрый способ очистки содержимого файла?

```
>foo
```

А какой самый быстрый способ очистки содержимого файла в случае активации параметра командной оболочки noclobber?

```
>|bar
```

### 4.2 Фильтры
#### Фильтр cat
При размещении фильтра cat между двумя программными каналами не будет осуществляться какой-либо обработки передающихся через них данных (за исключением передачи этих данных из стандартного потока ввода stdin в стандартный поток вывода stdout фильтра).
```
[paul@RHEL4b pipes]$ tac count.txt | cat | cat | cat | cat | cat
пять
четыре
три
два
один
[paul@RHEL4b pipes]$
```

#### Фильтр tee
Создание сложных конвейеров при работе с интерфейсом командной строки системы Unix является занимательным процессом, но иногда вам могут потребоваться промежуточные результаты работы конвейера. Это именно тот случай, когда фильтр tee может оказаться очень полезным. Фильтр tee перемещает данные из стандартного потока ввода stdin в стандартный поток вывода stdout, а также записывает их в файл. Исходя из вышесказанного, фильтр tee функционирует аналогично фильтру cat, за исключением того, что он имеет два идентичных вывода.
```
[paul@RHEL4b pipes]$ tac count.txt | tee temp.txt | tac
один
два
три
четыре
пять
[paul@RHEL4b pipes]$ cat temp.txt
пять
четыре
три
два
один
[paul@RHEL4b pipes]$
```

#### Фильтр grep
Фильтр grep снискал известность среди пользователей систем Unix. Наиболее простым сценарием использования фильтра grep является фильтрация строк текста, содержащих (или не содержащих) определенную подстроку.
```
[paul@RHEL4b pipes]$ cat tennis.txt
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$ cat tennis.txt | grep Williams
Serena Williams, usa
Venus Williams, USA
```
Вы можете выполнить эту же задачу без задействования фильтра cat.
```
[paul@RHEL4b pipes]$ grep Williams tennis.txt
Serena Williams, usa
Venus Williams, USA
```
Одним из наиболее полезных параметров фильтра grep является параметр grep -i, который позволяет производить фильтрацию строк без учета регистра.
```
[paul@RHEL4b pipes]$ grep Bel tennis.txt
Justine Henin, Bel
[paul@RHEL4b pipes]$ grep -i Bel tennis.txt
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$
```
Другим полезным параметром является параметр grep -v, который позволяет осуществлять вывод строк, не содержащих заданную строку.
```
[paul@RHEL4b pipes]$ grep -v Fra tennis.txt
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
Venus Williams, USA
[paul@RHEL4b pipes]$
```
И, конечно же, оба описанных выше параметра могут комбинироваться для фильтрации всех строк без учета регистра и вывода тех из них, которые не содержат заданной строки.
```
[paul@RHEL4b pipes]$ grep -vi usa tennis.txt
Amelie Mauresmo, Fra
Kim Clijsters, BEL
Justine Henin, Bel
[paul@RHEL4b pipes]$
```

При использовании параметра grep -A1 в вывод также будет добавлена одна строка, располагающаяся после обнаруженной строки.
```
paul@debian5:~/pipes$ grep -A1 Henin tennis.txt
Justine Henin, Bel
Serena Williams, usa
```

В случае использования параметра grep -B1 в вывод будет добавлена одна строка, располагающаяся до обнаруженной строки.
```
paul@debian5:~/pipes$ grep -B1 Henin tennis.txt
Kim Clijsters, BEL
Justine Henin, Bel
```

С помощью параметра grep -C1 (контекст) в вывод может быть добавлена одна строка, находящейся до обнаруженной строки, и одна строка, находящаяся после нее. Все три параметра (A, B и C) могут быть использованы для вывода произвольного количества дополнительных строк (например, могут быть использованы параметры A2, B4 или C20).
```
paul@debian5:~/pipes$ grep -C1 Henin tennis.txt
Kim Clijsters, BEL
Justine Henin, Bel
Serena Williams, usa
```

#### Фильтр cut
Фильтр cut может использоваться для извлечения данных из столбцов расположенных в файлах таблиц с указанием разделителя столбцов или количества байт данных в столбцах. В примере ниже фильтр cut используется для извлечения имени пользователя и его идентификатора из файла /etc/passwd. В качестве разделителя столбцов таблицы из данного файла используется символ двоеточия, при этом производится выборка значений первого и третьего столбцов.
```
[paul@RHEL4b pipes]$ cut -d: -f1,3 /etc/passwd | tail -4
Figo:510
Pfaff:511
Harry:516
Hermione:517
[paul@RHEL4b pipes]$
```
В случае использования фильтра cut с символом пробела в качестве разделителя вам придется экранировать этот символ пробела.
```
[paul@RHEL4b pipes]$ cut -d" " -f1 tenn is.txt
Amelie
Kim
Justine
Serena
Venus
[paul@RHEL4b pipes]$
```
А в данном примере фильтр cut используется для вывода фрагментов строк файла /etc/passwd со второго по седьмой символ.
```
[paul@RHEL4b pipes]$ cut -c2-7 /etc/passwd | tail -4
igo:x:
faff:x
arry:x
ermion
[paul@RHEL4b pipes]$
```

#### Фильтр tr
Вы можете преобразовывать символы с помощью фильтра tr. В примере ниже показана процедура преобразования всех обнаруженных в потоке данных символов e в символы E.
```
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'e' 'E'
AmEliE MaurEsmo, Fra
Kim ClijstErs, BEL
JustinE HEnin, BEl
SErEna Williams, usa
VEnus Williams, USA
```
В данном случае мы переводим все буквенные символы в верхний регистр, указывая два диапазона значений.
```
[paul@RHEL4b pipes]$ cat tennis.txt | tr 'a-z' 'A-Z'
AMELIE MAURESMO, FRA
KIM CLIJSTERS, BEL
JUSTINE HENIN, BEL
SERENA WILLIAMS, USA
VENUS WILLIAMS, USA
[paul@RHEL4b pipes]$
```
А здесь мы преобразовываем все символы новых строк в символы пробелов.
```
[paul@RHEL4b pipes]$ cat count.txt
один
два
три
четыре
пять
[paul@RHEL4b pipes]$ cat count.txt | tr '\n' ' '
один два три четыре пять [paul@RHEL4b pipes]$
```
Параметр tr -s также может использоваться для преобразования последовательностей из множества заданных символов в один символ.
```
[paul@RHEL4b pipes]$ cat spaces.txt
один    два        три
четыре   пять  шесть
[paul@RHEL4b pipes]$ cat spaces.txt | tr -s ' '
один два три
четыре пять шесть
[paul@RHEL4b pipes]$
```
Вы можете использовать фильтр tr даже для 'шифрования' текстов с использованием алгоритма rot13.
```
[paul@RHEL4b pipes]$ cat count.txt
one
two
three
four
five
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'nopqrstuvwxyzabcdefghijklm'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$ cat count.txt | tr 'a-z' 'n-za-m'
bar
gjb
guerr
sbhe
svir
[paul@RHEL4b pipes]$
```
В последнем примере мы используем параметр tr -d для удаления заданного символа.
```
paul@debian5:~/pipes$ cat tennis.txt | tr -d e
Amli Maursmo, Fra
Kim Clijstrs, BEL
Justin Hnin, Bl
Srna Williams, usa
Vnus Williams, USA
```

#### Фильтр wc
Подсчет слов, строк и символов в файле осуществляется достаточно просто в случае использования фильтра wc.
```
[paul@RHEL4b pipes]$ wc tennis.txt
5  15 100 tennis.txt
[paul@RHEL4b pipes]$ wc -l tennis.txt
5 tennis.txt
[paul@RHEL4b pipes]$ wc -w tennis.txt
15 tennis.txt
[paul@RHEL4b pipes]$ wc -c tennis.txt
100 tennis.txt
[paul@RHEL4b pipes]$
```

#### Фильтр sort
Фильтр sort по умолчанию сортирует строки файла в алфавитном порядке.
```
paul@debian5:~/pipes$ cat music.txt
Queen
Brel
Led Zeppelin
Abba
paul@debian5:~/pipes$ sort music.txt
Abba
Brel
Led Zeppelin
Queen
```
Но при этом фильтр sort поддерживает большое количество параметров, позволяющих повлиять на принцип его работы. В следующем примере показана методика сортировки строк на основе значений различных столбцов (столбца 1 и столбца 2 соответственно).
```
[paul@RHEL4b pipes]$ sort -k1 country.txt
Belgium, Brussels, 10
France, Paris, 60
Germany, Berlin, 100
Iran, Teheran, 70
Italy, Rome, 50
[paul@RHEL4b pipes]$ sort -k2 country.txt
Germany, Berlin, 100
Belgium, Brussels, 10
France, Paris, 60
Italy, Rome, 50
Iran, Teheran, 70
```

В примере ниже продемонстрировано различие между сортировкой в алфавитном порядке и сортировкой по числовым значениям (обе сортировки осуществлены на основе значений из третьего столбца).
```
[paul@RHEL4b pipes]$ sort -k3 country.txt
Belgium, Brussels, 10
Germany, Berlin, 100
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
[paul@RHEL4b pipes]$ sort -n -k3 country.txt
Belgium, Brussels, 10
Italy, Rome, 50
France, Paris, 60
Iran, Teheran, 70
Germany, Berlin, 100
```

#### Фильтр uniq
С помощью фильтра uniq вы можете удалить повторяющиеся строки из отсортированного списка строк.
```
paul@debian5:~/pipes$ cat music.txt
Queen
Brel
Queen
Abba
paul@debian5:~/pipes$ sort music.txt
Abba
Brel
Queen
Queen
paul@debian5:~/pipes$ sort music.txt |uniq
Abba
Brel
Queen
```

Также в случае использования параметра -c фильтр uniq может вести подсчет повторений строк.
```
paul@debian5:~/pipes$ sort music.txt |uniq -c
1 Abba
1 Brel
2 Queen
```

#### Фильтр comm
Сравнение потоков данных (или файлов) может быть осуществлено с помощью фильтра comm. По умолчанию фильтр comm будет выводить данные в трех столбцах. В данном примере строки Abba, Cure и Queen присутствуют в списках из обоих файлов, строки Bowie и Sweet только в списке из первого файла, а строка Turnet - только в списке из второго файла.
```
paul@debian5:~/pipes$ cat > list1.txt
Abba
Bowie
Cure
Queen
Sweet
paul@debian5:~/pipes$ cat > list2.txt
Abba
Cure
Queen
Turner
paul@debian5:~/pipes$ comm list1.txt list2.txt
Abba
Bowie
Cure
Queen
Sweet
Turner
```

Вывод фильтра comm лучше читается в случае формирования одного столбца. При этом с помощью цифровых параметров должны быть указаны столбцы, содержимое которых не должно выводиться.
```
paul@debian5:~/pipes$ comm -12 list1.txt list2.txt
Abba
Cure
Queen
paul@debian5:~/pipes$ comm -13 list1.txt list2.txt
Turner
paul@debian5:~/pipes$ comm -23 list1.txt list2.txt
Bowie
Sweet
```

#### Фильтр od
Несмотря на то, что жители Европы предпочитают работать с символами ascii, компьютеры используют байты для хранения данных файлов. В примере ниже создается простой файл, после чего для показа его содержимого в форме шестнадцатеричных значений байт используется фильтр od.
```
paul@laika:~/test$ cat > text.txt
abcdefg
1234567
paul@laika:~/test$ od -t x1 text.txt
0000000 61 62 63 64 65 66 67 0a 31 32 33 34 35 36 37 0a
0000020
```
Содержимое этого же файла может быть выведено и в форме восьмеричных значений байт.
```
paul@laika:~/test$ od -b text.txt
0000000 141 142 143 144 145 146 147 012 061 062 063 064 065 066 067 012
0000020
```
А это содержимое рассматриваемого файла в форме символов ascii (или экранированных символов).
```
paul@laika:~/test$ od -c text.txt
0000000   a   b   c   d   e   f   g  \n   1   2   3   4   5   6   7  \n
0000020
```

#### Фильтр sed
Фильтр sed (расшифровывается как stream editor - редактор потока данных) позволяет выполнять различные операции редактирования при обработке потока данных с задействованием регулярных выражений.
```
paul@debian5:~/pipes$ echo уровень5 | sed 's/5/42/'
уровень42
paul@debian5:~/pipes$ echo уровень5 | sed 's/уровень/переход/'
переход5
```
Следует добавить флаг регулярного выражения g для осуществления глобальной замены (замены всех вхождений заданной строки в строку из потока данных).
```
paul@debian5:~/pipes$ echo уровень5 уровень7 | sed 's/уровень/переход/'
переход5 уровень7
paul@debian5:~/pipes$ echo уровень5 уровень7 | sed 's/уровень/переход/g'
переход5 переход7
```
С помощью флага регулярного выражения d вы можете осуществить удаление строк, содержащих заданную последовательность символов, из потока данных.
```
paul@debian5:~/test42$ cat tennis.txt
Venus Williams, USA
Martina Hingis, SUI
Justine Henin, BE
Serena williams, USA
Kim Clijsters, BE
Yanina Wickmayer, BE
paul@debian5:~/test42$ cat tennis.txt | sed '/BE/d'
Venus Williams, USA
Martina Hingis, SUI
Serena williams, USA
```

#### Примеры конвейеров
Конвейер who | wc

Сколькими пользователями был осуществлен вход в систему?
```
[paul@RHEL4b pipes]$ who
root     tty1         июл 25 10:50
paul     pts/0        июл 25 09:29 (laika)
Harry    pts/1        июл 25 12:26 (barry)
paul     pts/2        июл 25 12:26 (pasha)
[paul@RHEL4b pipes]$ who | wc -l
4
```

Конвейер who | cut | sort

Вывод отсортированного списка пользователей, осуществивших вход в систему.
```
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort
Harry
paul
paul
root
```

Вывод отсортированного списка пользователей, осуществивших вход в систему, в котором имя каждого пользователя приводится лишь единожды.
```
[paul@RHEL4b pipes]$ who | cut -d' ' -f1 | sort | uniq
Harry
paul
root
```

Конвейер grep | cut

Вывод списка всех учетных записей пользователей, использующих командную оболочку bash на данном компьютере. Учетные записи пользователей будут подробно обсуждаться позднее.
```
paul@debian5:~$ grep bash /etc/passwd
root:x:0:0:root:/root:/bin/bash
paul:x:1000:1000:paul,,,:/home/paul:/bin/bash
serena:x:1001:1001::/home/serena:/bin/bash
paul@debian5:~$ grep bash /etc/passwd | cut -d: -f1
root
paul
serena
```


### 4.3 Стандартные инструменты систем Unix
#### Утилита find
Утилита find может выполнять полезную работу в начале конвейера в случае возникновения необходимости в поиске файлов. Ниже представлено несколько примеров ее использования. Вы также можете рассмотреть возможность добавления конструкции для перенаправления стандартного потока ошибок 2>/dev/null в строки команд для того, чтобы ваш экран не заполнялся сообщениями об ошибках.

Команда для поиска всех файлов в директории /etc и сохранения списка имен найденных файлов в файле etcfiles.txt:
```
find /etc > etcfiles.txt
```

Команда для поиска файлов во всей файловой системе и сохранения списка имен найденных файлов в файле allfiles.txt:
```
find / > allfiles.txt
```

Команда для поиска файлов с расширением .conf в текущей директории (и всех поддиректориях):
```
find . -name "*.conf"
```

Команда для поиска обычных файлов с расширением .conf и явным указанием типа этих файлов (без директорий, именованных каналов и других файлов специальных типов):
```
find . -type f -name "*.conf"
```

Команда для поиска файлов специального типа, представляющих директории, с расширением .bak:
```
find /data -type d -name "*.bak"
```

Команда для поиска файлов, созданных позднее файла file42.txt:
```
find . -newer file42.txt
```

Утилита find также может исполнять произвольные команды для обработки каждого из найденных файлов. В данном примере мы осуществляем поиск файлов с расширением *.odf и копируем их в директорию /backup/.
```
find /data -name "*.odf" -exec cp {} /backup/ \;
```

Кроме того, утилита find может запрашивать подтверждение перед исполнением заданной команды для обработки каждого из найденных файлов. В данном примере файлы с расширением *.odf будут удаляться в том случае, если вы подтвердите необходимость исполнения этой операции для каждого из найденных файлов.
```
find /data -name "*.odf" -ok rm {} \;
```

#### Утилита locate
Утилита locate имеет значительное отличие от утилиты find, заключающееся в том, что она использует данные индексирования файловой системы для установления путей к файлам. Несмотря на то, что данный алгоритм поиска гораздо быстрее алгоритма с обходом всех директорий файловой системы, в случае его использования данные о файловой системе в подавляющем большинстве случаев являются устаревшими. В том случае, если данные индексирования файловой системы еще не собраны, вам придется осуществить их сбор путем выполнения команды updatedb (в дистрибутиве Red Hat Enterprise Linux для выполнения описанной операции понадобятся привилегии пользователя root).
```
[paul@RHEL4b ~]$ locate Samba
locate: не удалось выполнить stat () "/var/lib/mlocate/mlocate.db": Нет такого файла или каталога
[paul@RHEL4b ~]$ updatedb
updatedb: не удалось открыть временный файл для "/var/lib/mlocate/mlocate.db"
[paul@RHEL4b ~]$ su -
Password:
[root@RHEL4b ~]# updatedb
[root@RHEL4b ~]#
```

В большинстве дистрибутивов Linux для исполнения команды updatedb один раз в день используется планировщик задач.

#### Утилита date
Утилита date может использоваться для вывода информации о дате, времени, часовом поясе, а также дополнительной информации.
```
paul@rhel55 ~$ date
Sat Apr 17 12:44:30 CEST 2010
```

Форматирование строки с информацией о дате может быть изменено в соответствии с вашими предпочтениями. Обратитесь к странице руководства для получения информации о других параметрах форматирования.
```
paul@rhel55 ~$ date +'%A %d-%m-%Y'
Суббота 17-04-2010
```

Во всех системах Unix для подсчета времени используется количество секунд, прошедших с 1969 года (первой секундой является первая секунда первого дня января 1970 года). Для вывода времени Unix в секундах может использоваться команда date +%s.
```
paul@rhel55 ~$ date +%s
1271501080
```

Когда же значение этого счетчика достигнет двух миллиардов секунд?
```
paul@rhel55 ~$ date -d '1970-01-01 + 2000000000 seconds'
Ср май 18 03:33:20 MSK 2033
```

#### Утилита cal
Утилита cal выводит календарь для текущего месяца, в котором выделен текущий день.
```
Апрель 2010     
Пн Вт Ср Чт Пт Сб Вс
1  2  3
4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29 30
```

Вы можете выбрать любой месяц из прошлого или будущего.
```
paul@rhel55 ~$ cal 2 1970
Февраль 1970    
Пн Вт Ср Чт Пт Сб Вс
1  2  3  4  5  6  7
8  9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
```

#### Утилита sleep
Утилита sleep иногда используется в сценариях для перехода в режим ожидания на заданный промежуток времени в секундах. В данном примере показана методика реализации пятисекундного периода ожидания с использованием утилиты sleep.
```
paul@rhel55 ~$ sleep 5
paul@rhel55 ~$
```

#### Команда time
Команда time выводит информацию о том, сколько времени тратится на исполнение заданной команды. На исполнение команды date тратится совсем немного времени.
```
paul@rhel55 ~$ time date
Суб Апр 17 13:08:27 CEST 2010

real    0m0.014s
user    0m0.008s
sys     0m0.006s
```

Команда sleep 5 исполняется в течение пяти секунд реального времени, но при этом на ее исполнение тратится совсем немного процессорного времени.
```
paul@rhel55 ~$ time sleep 5

real    0m5.018s
user    0m0.005s
sys     0m0.011s
```

А на исполнение команды bzip2, осуществляющей сжатие файла, тратится достаточно много процессорного времени.
```
paul@rhel55 ~$ time bzip2 text.txt

real    0m2.368s
user    0m0.847s
sys     0m0.539s
```

#### Утилиты gzip - gunzip
Пользователям всегда недостаточно дискового пространства, поэтому инструменты для сжатия данных всегда актуальны. Утилита gzip позволяет осуществить преобразования файлов, после которых они будут занимать меньше дискового пространства.
```
paul@rhel55 ~$ ls -lh text.txt
-rw-rw-r-- 1 paul paul 6.4M апр 17 13:11 text.txt
paul@rhel55 ~$ gzip text.txt
paul@rhel55 ~$ ls -lh text.txt.gz
-rw-rw-r-- 1 paul paul 760K апр 17 13:11 text.txt.gz
```

Вы можете получить оригинал вашего файла, воспользовавшись утилитой gunzip.
```
paul@rhel55 ~$ gunzip text.txt.gz
paul@rhel55 ~$ ls -lh text.txt
-rw-rw-r-- 1 paul paul 6.4M апр 17 13:11 text.txt
```

#### Утилиты zcat - zmore
Содержимое текстовых файлов, сжатых с помощью утилиты gzip, может быть просмотрено с помощью утилит zcat и zmore.
```
paul@rhel55 ~$ head -4 text.txt
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
paul@rhel55 ~$ gzip text.txt
paul@rhel55 ~$ zcat text.txt.gz | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
```

#### Утилиты bzip2 - bunzip2
Файлы также могут сжиматься с помощью утилиты bzip2, которая, несмотря на немного большие по сравнению с утилитой gzip затраты времени, позволяет достичь лучших показателей сжатия данных.
```
paul@rhel55 ~$ bzip2 text.txt
paul@rhel55 ~$ ls -lh text.txt.bz2
-rw-rw-r-- 1 paul paul 569K апр 17 13:11 text.txt.bz2
```

Декомпрессия результирующих файлов может быть осуществлена с помощью утилиты bunzip2.
```
paul@rhel55 ~$ bunzip2 text.txt.bz2
paul@rhel55 ~$ ls -lh text.txt
-rw-rw-r-- 1 paul paul 6.4M аpr 17 13:11 text.txt
```

#### Утилиты bzcat - bzmore
И, аналогичным образом, с помощью утилит bzcat и bzmore может осуществляться вывод содержимого файлов, сжатых с использованием утилиты bzip2.
```
paul@rhel55 ~$ bzip2 text.txt
paul@rhel55 ~$ bzcat text.txt.bz2 | head -4
/
/opt
/opt/VBoxGuestAdditions-3.1.6
/opt/VBoxGuestAdditions-3.1.6/routines.sh
```


### 4.3 Регулярные выражения
#### Версии синтаксисов регулярных выражений
Существуют три различных версии синтаксисов регулярных выражений:
BRE: Basic Regular Expressions (Базовый синтаксис регулярных выражений)
ERE: Extended Regular Expressions (Расширенный синтаксис регулярных выражений)
PCRE: Perl Regular Expressions (Синтаксис регулярных выражений языка программирования Perl)
В зависимости от используемого инструмента может использоваться один или несколько упомянутых синтаксисов.

К примеру, инструмент grep поддерживает параметр -E, позволяющий принудительно использовать расширенный синтаксис регулярных выражений (ERE) при разборе регулярного выражения, в то в время, как параметр -G позволяет принудительно использовать базовый синтаксис регулярных выражений (BRE), а параметр -P - синтаксис регулярных выражений языка программирования Perl (PCRE).

Учтите и то, что инструмент grep также поддерживает параметр -F, позволяющий прочитать регулярное выражение без обработки.

Инструмент sed также поддерживает параметры, позволяющие выбирать синтаксис регулярных выражений.

Всегда читайте страницы руководств используемых инструментов!

#### Утилита grep
###### Вывод строк, совпадающих с шаблоном

Утилита grep является популярным инструментом систем Linux, предназначенным для поиска строк, которые совпадают с определенным шаблоном. Ниже приведены примеры простейших регулярных выражений, которые могут использоваться при работе с ним.

Это содержимое используемого в примерах тестового файла. Данный файл содержит три строки (или три символа новой строки).
```
paul@rhel65:~$ cat names
Tania
Laura
Valentina
```

При поиске отдельного символа будут выводиться только те строки, которые содержат заданный символ.
```
paul@rhel65:~$ grep u names
Laura
paul@rhel65:~$ grep e names
Valentina
paul@rhel65:~$ grep i names
Tania
Valentina
```

Сравнение с шаблоном, использованным в данном примере, осуществляется очевидным образом; в том случае, если заданный символ встречается в строке, утилита grep выведет эту строку.

###### Объединение символов

Для поиска сочетаний символов в строках символы регулярного выражения должны объединяться аналогичным образом.

В данном примере демонстрируется принцип работы утилиты grep, в соответствии с которым регулярному выражению ia будет соответствовать строка Tania, но не строка Valentina, а регулярному выражению in - строка Valentina, но не строка Tania.
```
paul@rhel65:~$ grep a names
Tania
Laura
Valentina
paul@rhel65:~$ grep ia names
Tania
paul@rhel65:~$ grep in names
Valentina
paul@rhel65:~$
```

###### Один или другой символ

Как в синтаксисе PCRE, так и в синтаксисе ERE может использоваться символ создания программного канала, который в данном случае будет представлять логическую операцию "ИЛИ". В данном примере мы будем искать с помощью утилиты grep строки, в которых встречается символ i или символ a.
```
paul@debian7:~$ cat list
Tania
Laura
paul@debian7:~$ grep -E 'i|a' list
Tania
Laura
```

Обратите внимание на то, что мы используем параметр -E утилиты grep для принудительной интерпретации нашего регулярного выражения как выражения, использующего расширенный синтаксис регулярных выражений (ERE).

Нам придется экранировать символ создания программного канала в регулярном выражении, использующем базовый синтаксис регулярных выражений (BRE) для аналогичной интерпретации этого символа в качестве логической операции "ИЛИ".
```
paul@debian7:~$ grep -G 'i|a' list
paul@debian7:~$ grep -G 'i\|a' list
Tania
Laura
```

###### Одно или большее количество совпадений

Символ * соответствует нулю, одному или большему количеству вхождений предыдущего символа, а символ + одному или большему количеству вхождений предыдущего символа ﻿.
```
paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o*' list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o+' list2
lol
lool
loool
paul@debian7:~$
```

###### Совпадение в конце строки

В следующих примерах мы будем использовать данный файл:
```
paul@debian7:~$ cat names
Tania
Laura
Valentina
Fleur
Floor
```

В двух примерах ниже показана методика использования символа доллара для поиска совпадения в конце строки.
```
paul@debian7:~$ grep a$ names
Tania
Laura
Valentina
paul@debian7:~$ grep r$ names
Fleur
Floor
```

###### Совпадение в начале строки

Символ вставки (^) позволяет осуществлять поиск совпадения в начале (или с первых символов) строки.

В данных примерах используется рассмотренный выше файл.
```
paul@debian7:~$ grep ^Val names
Valentina
paul@debian7:~$ grep ^F names
Fleur
Floor
```

Символы доллара и вставки, используемые в регулярных выражениях, называются якорями (anchors).

###### Разделение слов

Последовательность символов \b может использоваться в регулярных выражениях в качестве разделителя слов. Рассмотрим в качестве примера следующий файл:
```
paul@debian7:~$ cat text
The governer is governing.
The winter is over.
Can you get over there?
```

При простом поиске строки over будет выведено слишком много результирующих строк.
```
paul@debian7:~$ grep over text
The governer is governing.
The winter is over.
Can you get over there?
```

Экранирование разыскиваемых слов с помощью символов пробелов не является удачным решением (так как другие символы также могут использоваться в качестве разделителей слов). В примере ниже показана методика использования последовательности символов \b для поиска строк с заданным словом, а не последовательностью символов:
```
paul@debian7:~$ grep '\bover\b' text
The winter is over.
Can you get over there?
paul@debian7:~$
```

Обратите внимание на то, что утилита grep также поддерживает параметр -w, предназначенный для осуществления поиска по словам.
```
paul@debian7:~$ cat text
The governer is governing.
The winter is over.
Can you get over there?
paul@debian7:~$ grep -w over text
The winter is over.
Can you get over there?
paul@debian7:~$
```

###### Параметры утилиты grep

Иногда оказывается проще скомбинировать простое регулярное выражение с параметрами утилиты grep, нежели создать более сложное регулярное выражение. Эти параметры обсуждались ранее:
```
grep -i
grep -v
grep -w
grep -A5
grep -B5
grep -C5
```

###### Предотвращение раскрытия регулярного выражения командной оболочкой

Символ доллара является специальным символом как для регулярного выражения, так и для командной оболочки (вспомните о переменных командной оболочки и встраиваемых командных оболочках). Исходя из этого, рекомендуется при любых обстоятельствах экранировать регулярные выражения, так как экранирование регулярного выражения позволяет предотвратить раскрытие этого выражения командной оболочкой.
```
paul@debian7:~$ grep 'r$' names
Fleur
Floor
rename
```

#### Утилита rename
###### Реализации утилиты rename

В дистрибутиве Debain Linux по пути /usr/bin/rename расположена ссылка на сценарий /usr/bin/prename, устанавливаемый из пакета perl.
```
paul@pi ~ $ dpkg -S $(readlink -f $(which rename))
perl: /usr/bin/prename
```

В дистрибутивах, основанных на дистрибутиве Red Hat, не создается аналогичной символьной ссылки для указания на описанный сценарий (конечно же, за исключением тех случаев, когда создается символьная ссылка на сценарий, установленный вручную), поэтому в данном разделе не будет описываться реализация утилиты rename из дистрибутива Red Hat.

В дискуссиях об утилите rename в сети Интернет обычно происходит путаница из-за того, что решения, которые отлично работают в дистрибутиве Debian (а также Ubuntu, xubuntu, Mint, ...), не могут использоваться в дистрибутиве Red Hat (а также CentOS, Fedora, ...).

###### Пакет perl

Команда rename на самом деле реализована в форме сценария, использующего регулярные выражения языка программирования perl. С полным руководством по использованию данного сценария можно ознакомиться после ввода команды perldoc perlrequick (после установки пакета perldoc).
```
root@pi:~# aptitude install perl-doc
Следующие НОВЫЕ пакеты будут установлены:
perl-doc
0 пакетов обновлено, 1 установлено новых, 0 пакетов отмечено для удаления, и 0 пакетов не обновлено.
Необходимо получить 8,170 kB архивов. После распаковки 13.2 MB будет занято.
Получить: 1 http://mirrordirector.raspbian.org/raspbian/ wheezy/main perl-do...
Получено 8,170 kБ в 19с (412 kБ/с)
Выбор ранее не выбранного пакета perl-doc.
(Чтение базы данных ... на данный момент установлено 67121 файл и каталог.)
Распаковывается perl-doc (из .../perl-doc_5.14.2-21+rpi2_all.deb) ...
Adding 'diversion of /usr/bin/perldoc to /usr/bin/perldoc.stub by perl-doc'
Обрабатываются триггеры для man-db ...
Настраивается пакет perl-doc (5.14.2-21+rpi2) ...

root@pi:~# perldoc perlrequick
```
###### Хорошо известный синтаксис

Чаще всего утилита rename используется для поиска файлов с именами, соответствующими определенному шаблону в форме строки, и замены данной строки на другую строку.

Обычно данное действие описывается с помощью регулярного выражения s/строка/другая строка/, как показано в примере:
```
paul@pi ~ $ ls
abc       allfiles.TXT  bllfiles.TXT  Scratch   tennis2.TXT
abc.conf  backup        cllfiles.TXT  temp.TXT  tennis.TXT
paul@pi ~ $ rename 's/TXT/text/' *
paul@pi ~ $ ls
abc       allfiles.text  bllfiles.text  Scratch    tennis2.text
abc.conf  backup         cllfiles.text  temp.text  tennis.text
```

А ниже приведен другой пример, в котором используется хорошо известный синтаксис утилиты rename для повторного изменения расширений тех же файлов:
```
paul@pi ~ $ ls
abc       allfiles.text  bllfiles.text  Scratch    tennis2.text
abc.conf  backup         cllfiles.text  temp.text  tennis.text
paul@pi ~ $ rename 's/text/txt/' *.text
paul@pi ~ $ ls
abc       allfiles.txt  bllfiles.txt  Scratch   tennis2.txt
abc.conf  backup        cllfiles.txt  temp.txt  tennis.txt
paul@pi ~ $
```

Эти два примера являются работоспособными по той причине, что используемые нами строки встречаются исключительно в расширениях файлов. Не забывайте о том, что расширения файлов не имеют значения при работе с командной оболочкой bash.

В следующем примере продемонстрирована проблема, с которой можно столкнуться при использовании данного синтаксиса.
```
paul@pi ~ $ touch atxt.txt
paul@pi ~ $ rename 's/txt/problem/' atxt.txt
paul@pi ~ $ ls
abc       allfiles.txt  backup        cllfiles.txt  temp.txt     tennis.txt
abc.conf  aproblem.txt  bllfiles.txt  Scratch       tennis2.txt
paul@pi ~ $
```

При исполнении рассматриваемой команды осуществляется замена исключительно первого вхождения разыскиваемой строки.

###### Глобальная замена

Синтаксис, использованный в предыдущем примере, может быть описан следующим образом: s/регулярное выражение/строка для замены/. Это описание является простым и очевидным, так как вам придется всего лишь разместить регулярное выражение между двумя первыми слэшами и строку для замены между двумя последними слэшами.

В следующем примере данный синтаксис немного расширяется благодаря добавлению модификатора.
```
paul@pi ~ $ rename -n 's/TXT/txt/g' aTXT.TXT
aTXT.TXT renamed as atxt.txt
paul@pi ~ $
```

Теперь используемый нами синтаксис может быть описан как s/регулярное выражение/строка для замены/g, где модификатор s обозначает операцию замены (switch), а модификатор g - сообщает о необходимости осуществления глобальной замены (global).

Обратите внимание на то, что в данном примере был использован параметр -n для вывода информации о выполняемой операции (вместо выполнения самой операции, заключающейся в непосредственном переименовании файла).

###### Замена без учета регистра

Другим модификатором, который может оказаться полезным, является модификатор i. В примере ниже показана методика замены строки на другую строку без учета регистра.
```
paul@debian7:~/files$ ls
file1.text  file2.TEXT  file3.txt
paul@debian7:~/files$ rename 's/.text/.txt/i' *
paul@debian7:~/files$ ls
file1.txt  file2.txt  file3.txt
paul@debian7:~/files$
```

###### Изменение расширений

Интерфейс командной строки Linux не имеет представления о расширениях файлов, аналогичных применяемым в операционной системе MS-DOS, но многие пользователи и приложения с графическим интерфейсом используют их.

В данном разделе приведен пример использования утилиты rename для изменения исключительно расширений файлов. В примере используется символ доллара для указания на то, что точкой отсчета для замены является окончание имени файла.
```
paul@pi ~ $ ls *.txt
allfiles.txt  bllfiles.txt  cllfiles.txt  really.txt.txt  temp.txt  tennis.txt
paul@pi ~ $ rename 's/.txt$/.TXT/' *.txt
paul@pi ~ $ ls *.TXT
allfiles.TXT  bllfiles.TXT    cllfiles.TXT    really.txt.TXT
temp.TXT      tennis.TXT
paul@pi ~ $
```

Обратите внимание на то, что символ доллара в рамках регулярного выражения обозначает окончание строки. Без символа доллара исполнение данной команды должно завершиться неудачей в момент обработки имени файла really.txt.txt.

#### Утилита sed
###### Редактор потока данных

Редактор потока данных (stream editor) или, для краткости, утилита sed, использует регулярные выражения для модификации потока данных.

В данном примере утилита sed используется для замены строки.
```
echo Понедельник | sed 's/Понедель/Втор/'
Вторник
```

Слэши могут быть заменены на некоторые другие символы, которые могут оказаться более удобными и повысить читаемость команды в ряде случаев.
```
echo Понедельник | sed 's:Понедель:Втор:'
Вторник
echo Понедельник | sed 's_Понедель_Втор_'
Вторник
echo Понедельник | sed 's|Понедель|Втор|'
Вторник
```

###### Интерактивный редактор

Несмотря на то, что утилита sed предназначена для обработки потоков данных, она также может использоваться для интерактивной обработки файлов.
```
paul@debian7:~/files$ echo Понедельник > today
paul@debian7:~/files$ cat today
Понедельник
paul@debian7:~/files$ sed -i 's/Понедель/Втор/' today
paul@debian7:~/files$ cat today
Вторник
```

###### Простые обратные ссылки

Символ амперсанда может использоваться для ссылки на искомую (и найденную) строку.

В данном примере амперсанд используется для удвоения количества найденных строк.
```
echo Понедельник | sed 's/Понедель/&&/'
ПонедельПонедельник
echo Понедельник | sed 's/ник/&&/'
Понедельникник
```

###### Обратные ссылки

Круглые скобки используются для группировки частей регулярного выражения, на которые впоследствии могут быть установлены ссылки.

Рассмотрите следующий пример:
```
paul@debian7:~$ echo Sunday | sed 's_\(Sun\)_\1ny_'
Sunnyday
paul@debian7:~$ echo Sunday | sed 's_\(Sun\)_\1ny \1_'
Sunny Sunday
```

###### Точка для обозначения любого символа

В регулярном выражении простой символ точки может обозначать любой символ.
```
paul@debian7:~$ echo 2014-04-01 | sed 's/....-..-../YYYY-MM-DD/'
YYYY-MM-DD
paul@debian7:~$ echo abcd-ef-gh | sed 's/....-..-../YYYY-MM-DD/'
YYYY-MM-DD
```

###### Множественные обратные ссылки

В случае использования более чем одной пары круглых скобок, ссылка на каждую из них может быть осуществлена путем использования последовательных числовых значений.
```
paul@debian7:~$ echo 2014-04-01 | sed 's/\(....\)-\(..\)-\(..\)/\1+\2+\3/'
2014+04+01
paul@debian7:~$ echo 2014-04-01 | sed 's/\(....\)-\(..\)-\(..\)/\3:\2:\1/'
01:04:2014
```

Данная возможность называется группировкой (grouping).

###### Пробел

Последовательность символов \s может использоваться для ссылки на такой символ, как символ пробела или табуляции.

В данном примере осуществляется глобальный поиск последовательностей символов пробелов (\s), которые заменяются на 1 символ пробела.
```
paul@debian7:~$ echo -e 'сегодня\tтеплый\tдень'
сегодня	теплый	день
paul@debian7:~$ echo -e 'сегодня\tтеплый\tдень' | sed 's_\s_ _g'
сегодня теплый день
```

###### Необязательные вхождения

Символ знака вопроса указывает на то, что предыдущий символ является необязательным.

В примере ниже осуществляется поиск последовательности из трех символов o, причем третий символ o является необязательным.
```
paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'ooo?' list2
lool
loool
paul@debian7:~$ cat list2 | sed 's/ooo\?/A/'
ll
lol
lAl
lAl
```

###### Ровно n повторений

Вы можете указать точное количество повторений предыдущего символа.

В данном примере осуществляется поиск строк с ровно тремя символами o.
```
paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o{3}' list2
loool
paul@debian7:~$ cat list2 | sed 's/o\{3\}/A/'
ll
lol
lool
lAl
paul@debian7:~$
```

###### От n до m повторений

А в данном примере мы четко указываем, что символ должен повторяться от минимального (2) до максимального (3) количества раз.
```
paul@debian7:~$ cat list2
ll
lol
lool
loool
paul@debian7:~$ grep -E 'o{2,3}' list2
lool
loool
paul@debian7:~$ grep 'o\{2,3\}' list2
lool
loool
paul@debian7:~$ cat list2 | sed 's/o\{2,3\}/A/'
ll
lol
lAl
lAl
paul@debian7:~$
```

#### История командной оболочки bash
Командная оболочка bash также может интерпретировать некоторые регулярные выражения.

В данном примере показана методика манипуляций с символом восклицательного знака в рамках маски поиска в истории командной оболочки bash.
```
paul@debian7:~$ mkdir hist
paul@debian7:~$ cd hist/
paul@debian7:~/hist$ touch file1 file2 file3
paul@debian7:~/hist$ ls -l file1
-rw-r--r-- 1 paul paul 0 апр 15 22:07 file1
paul@debian7:~/hist$ !l
ls -l file1
-rw-r--r-- 1 paul paul 0 апр 15 22:07 file1
paul@debian7:~/hist$ !l:s/1/3
ls -l file3
-rw-r--r-- 1 paul paul 0 Апр 15 22:07 file3
paul@debian7:~/hist$
```

Данная методика также работает в случае использования чисел при чтении истории команд командной оболочки bash.
```
paul@debian7:~/hist$ history 6
2089  mkdir hist
2090  cd hist/
2091  touch file1 file2 file3
2092  ls -l file1
2093  ls -l file3
2094  history 6
paul@debian7:~/hist$ !2092
ls -l file1
-rw-r--r-- 1 paul paul 0 апр 15 22:07 file1
paul@debian7:~/hist$ !2092:s/1/2
ls -l file2
-rw-r--r-- 1 paul paul 0 апр 15 22:07 file2
paul@debian7:~/hist$
```


